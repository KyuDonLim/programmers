# [PCCP 기출문제] 3번 / 아날로그 시계
---
## 📃 문제 설명
```
 시침, 분침, 초침이 있는 아날로그시계가 있습니다. 시계의 시침은 12시간마다, 분침은 60분마다, 초침은 60초마다 시계를 한 바퀴 돕니다.
 따라서 시침, 분침, 초침이 움직이는 속도는 일정하며 각각 다릅니다. 시계에는 초침이 시, 분침과 겹칠 때마다 알람이 울리는 기능이 있습니다.
 당신은 특정 시간 동안 알람이 울린 횟수를 알고 싶습니다.
 알람이 울리는 횟수를 센 시간을 나타내는 정수 h1, m1, s1, h2, m2, s2가 매개변수로 주어집니다.
 이때, 알람이 울리는 횟수를 return 하도록 solution 함수를 완성해주세요.
 [문제 조건]
  - 0 ≤ h1, h2 ≤ 23
  - 0 ≤ m1, m2 ≤ 59
  - 0 ≤ s1, s2 ≤ 59
  - h1시 m1분 s1초부터 h2시 m2분 s2초까지 알람이 울리는 횟수를 센다는 의미입니다.
  - h1시 m1분 s1초 < h2시 m2분 s2초
  - 시간이 23시 59분 59초를 초과해서 0시 0분 0초로 돌아가는 경우는 주어지지 않습니다.
```
---
## 🔔 초기 구상
```
 1. 0초를 기준으로 현재 초침과 시, 분침이 앞에 있는 지 파악
 2. 제공하는 두 시간(시작, 끝 시간)의 차이를 초 단위로 계산
 3. 계산된 시간을 반복문을 통해 해당 시간의 각을 계산
 4. 초침의 각도와 시, 분침의 각도를 비교하여 초침을 지나가는 여부를 파악
```
---
## ❌ 발생한 문제점
```
 1. 제공하는 두 시간이 큰 경우 시간 초과 발생 -> 모든 시간마다 % 연산을 하기 때문
```
---
## 📖 풀이 코드
```
class Solution {
    public int solution(int h1, int m1, int s1, int h2, int m2, int s2) {
        int t1 = hmsToSec(h1, m1, s1), t2 = hmsToSec(h2, m2, s2);
        return countAlram(t2) - countAlram(t1) + (alramNow(t1) ? 1 : 0);
    }

    private int hmsToSec(int h, int m, int s) {
        m += h * 60;
        s += m * 60;
        return s;
    }

    private int countAlram(int time) {
        int h_alram = time * 719 / 43200;
        int m_alram = time * 59 / 3600;
        int penalty = 43200 <= time ? 2 : 1;

        return h_alram + m_alram - penalty;
    }

    private boolean alramNow(int time) {
        return time * 719 % 43200 == 0 || time * 59 % 3600 == 0;
    }
}

```
---
## 💡 구현 내용
```
 1. 시작 시간 ~ 끝 시간의 만나는 횟수는 (0시 0분 0초 ~ 시작 시간) - (0시 0분 0초 ~ 시작 시간) + 시작 시 알림으로 표현 가능
   -> return countAlram(t2) - countAlram(t1) + (alramNow(t1) ? 1 : 0);
 2. 시침은 43200초마다 1바퀴를 돌고 초침은 720바퀴를 돈다. 시작 시간이 0초인 경우를 제외하곤 43200초 동안 719번의 알림이 울림
    따라서, 시침은 719 / 43200초마다 1번 울린다.
   -> int h_alram = time * 719 / 43200;
 3. 분침은 3600초마다 1바퀴를 돌고 초침은 60바퀴를 돈다. 시작 시간이 0초인 경우를 제외하곤 3600초 동안 59번의 알림이 울림
    따라서, 분침은 59 / 3600초마다 1번 울린다.
   -> int m_alram = time * 59 / 3600;
 4. 세 침이 한 곳에 모이는 경우(0시 0분 0초, 12시 0분 0초)에는 1번만 울리기 때문에 1회를 penalty
   -> int penalty = 43200 <= time ? 2 : 1;
 5. 시작 시간에서 알림일 울리는 지 확인하여 개수 추가
   -> time * 719 % 43200 == 0 || time * 59 % 3600 == 0;
```
---
## ✔ 문제 회고
```
 결론부터 말하면 이 문제를 해결하지 못하였다. 초기 구상 때 시간적인 문제가 발생할 것을 알았지만 다른 방식이 생각 나지 않은 것이
 아쉬웠다. 이 방식 말고 다른 풀이를 확인했을 때에는 고려해야 하는 조건이 더 많았다. 허나 위의 풀이처럼 논리적으로 생각한 후 코드를 짜니
 간결해지는 것뿐만 아니라 이해가 더욱 쉬웠다. 알고리즘을 풀면서 과거 SSAFY에서 가르쳐주신 교수님이 어려운 문제일수록 수학적으로 접근하여
 코드가 간결해질 수 있다는 이야기가 공감이 되었다. 단순한 구현말고도 수학적으로 접근하는 사고력을 키워야하는 것을 배울 수 있는 문제였다. 
```


